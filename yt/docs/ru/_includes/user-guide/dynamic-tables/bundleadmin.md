# Памятка администратора при использовании динамических таблиц

В этом разделе собрана информация, необходимая пользователю-администратору динамических таблиц: краткий обзор архитектуры, администраторского интерфейса, советы по capacity planning и диагностике


## Обзор архитектуры

Мы не будем копировать содержимое других разделов документации, но соберём то, что может быть наиболее актуально пользователю-администратору динамических таблиц.

### На одном кластере
В кластере YT узлы делятся на разные типы. При работе с динтаблицами в первую очередь используются Rpc Proxy, Tablet Node, но также запросы попадат на Data Node и Master. Опишем кратко их назначение:

* **Rpc Proxy** - узел кластера, принимающий запрос и передающий дальше. Прокся не хранит данные, её задача - разграничить внешнее пользовательское API и протокол общения внутри кластера. Прокси узнаёт, какая (или какие) Tablet Node отвечают за данные, запрашиваемые пользователем и отправляет запрос на них
* **Tablet Node** - в современной терминологии это *compute* слой динамических таблиц: он отвечает за все преобразования, вычисления и обработки транзакций, но непосредственно сырые данные не хранит. На Tablet Node нет дисков, в качестве стораджа используются Data Node
* **Data Node** - нода кластера с дисками, в которую в конечном счёте приходит чтение или запись. Физические носители бывают разных видов, в основном HDD и NVMe SSD, для сегрегации по разным типам дисков в YT используется понятие *медиума*. Динамические таблицы стоит располагать на медиуме ssd_blobs или nvme_blobs. Использовать HDD (медиум default) для динтаблиц не стоит. В частности, мы не оказываем помощь в поддержке динтаблиц на HDD.
* **Master** - метаданные YT кластера, содержащие дерево каталогов (Кипарис). Динтабличные операции ходят в мастер крайне редко, и через прослойку кешей, но помните, что в YT API команды хождения в динтаблицы и кипарис находятся рядом и возможный рейт выполнения таких команд будет отличаться на порядки


Пользователям динамических таблиц выделяются отдельные Tablet Node и Rpc Proxy. Для этого заводится tablet_cell_bundle для таблетных нод и proxy_role для проксей. Имена бандла и роли должны совпадать. Чтобы динамическая таблица обслуживалась вашим бандлом, его нужно указать в атрибуте tablet_cell_bundle таблицы или родительской директории. Лучше всего - навесить tablet_cell_bundle на вашу home-директорию, тогда все вновь созданные динтаблицы в этом подкаталоге (и, рекурсивно, его подкаталогах) будут с правильным бандлом. Для использования корректной роли поксей укажите proxy_role в конфиге [rpc proxy клиента](../../../user-guide/proxy/rpc#python).


### Федерация кластеров

Кластеров YT много, вы можете работать с каждым из них в отдельности, или использовать несколько для отказоустойчивости (например, в случае обновления кластера YT). Во втором случае вам нужно завести на каждом кластере свой бандл и свои rpc прокси. Есть несколько способов работы с федерацией кластеров:

1. Вы пользуетесь кластерами независимо друг от друга и самостоятельно решаете вопросы консистентности. Такое решение может подойти, если ваши контуры легко дублируются (например, данные готовятся в map-reduce) и вы можете пользоваться результатами от разных запусков
2. Используются *реплицированные таблицы*: на кластере репликации заводится реплицированная таблица, которая следит за тем чтобы данные до реплик на других кластерах доезжали строго консистентно
3. Используется *хаосная репликация*: аналогично реплицированным таблицам, передачу данных берёт на себя YT, но убирается единая точка отказа в виде кластера с реплицированной таблицей

В настоящее время большое количество пользователей используют реплицированные таблицы. Для тестинга кластером репликации выступает pythia а репликами zeno, freud, hume. Для продакшна кластером репликации выступает markov, а репликами seneca-\* или hahn,arnold. Напомним, что если вы отвечаете из динтаблиц внешним пользователям, надо использовать seneca-\*. Если внутренним - hahn или arnold.

## Architecture deep-dive

Чтобы адекватно ответить на вопрос потребления ресурсов, смочь его диагностировать и спрогносизровать, нужно хорошо понимать как приложение использует эти самые ресурсы. В этом разделе мы немного углубимся в архитектуру динтаблиц, причём посмотрим на неё с той стороны, которая больше всего актуальна администратору бандла.

### CPU, RAM, Net, Disks

Как и любое другое ПО, динтаблицы потребляют физические ресурсы машины: CPU, память, сеть и диски. В этом разделе мы опишем, как потребление этих ресурсов ограничивается в динтаблицах (да и в целом в YT).

* На любом хосте YT запущен многопоточный процесс, потоки (треды) которого в свою очередь объединены в *тредпулы*. Тредпулы отвечают за выполнение задач определённого вида: например, обработка lookup запросов осуществляется тредпулом TabletLookup. Вообще говоря тредпулов много и не каждый разработчик YT сможет их перечислить и сказать для чего они нужны, но мы выделили несколько, о которых полезно знать пользователям: уже упомянутый TabletLookup для лукапов, Query для селектов, Compression для сжатия/разжатия блоков, StoreCompactor для фонового компакшна и BusXFer для передачи пакетов по сети. У каждого тредпула фиксированный размер, что позволяет ограничить потребление CPU этим тредпулом. Обратите внимание, что есть техническая возможность переподписки тредпулов и физических ядер, доступных инстансу таблетной ноды: в случае если загрузка тредов будет превышать ограничения всего инстанса, треды начнут голодать, что приведёт к непредсказуемым и недиагностируемым задержкам времени отклика, поскольку треды будут попросту стоять в очереди на исполнение внутри ядра Linux

* Память процесса YT делится на категории, которым можно задавать фиксированный размер. Как правило пользователям динтаблиц в первую очередь нужно знать про категорию Tablet Static, в которой располагаются чанки динтаблиц, поднятых в память. При этом есть ещё несколько категорий и их размеры можно менять в зависимости от характеристик вашей нагрузки. Мы выделили несколько таких категорий: Tablet static (блоки, динтаблиц, поднятых в память), tablet dynamic (буфер новых строк при записи в таблицу), compressed block cache (кеш сжатых блоков), uncompressed block cache (кеш разжатых блоков), versioned chunk meta (кеш мет чанков динтаблиц), lookup row cache (кеш ответов для лукапов), key filter cache (кеш для фильтров отстутствующих ключей). Например, если вы не используете поднятие динтаблиц в память, то память категории tablet static будет попросту неиспользована, её было бы логичнее перераспределить на кеши блоков. Вообще говоря перераспределение памяти между категориями требует хорошего понимания нагрузки на бандл и на отдельные кеши. У большинства кешей есть графики, по которым можно судить об их заполненности и эффективности (hit rate). Как администратор бандла, вы должны понимать, что если ваша нагрузка существенно полагается на то что все данные оседают в кешах, то в момент, когда данные перестают помещаться в кеши вы увидите большую просадку в производительности, причём это может быть как ухудшение времени отклика, так и пропускной способности.

* Сеть нередко становится узким местом для динтаблиц. Как правило это возникает из-за того, что приходится читать много данных с дата нод, в результате прегеружается входящий интерфейс на таблетной ноде. Это связано с тем, что динтабличные блоки достаточно крупные: размер блока по умолчанию 256 килобайт. Другой случай: перегрузка исходящего интерфейса при большом потоке записи из-за дубликации в журналы и блобы. В настоящее время мы внедряем сетевые лимиты для инстансов таблетных нод, чтобы такие перегрузки хотя бы не мешали соседним подам на том же физическом хосте (это могут быть даже поды других бандлов)

* Как было написано выше, за общение с дисками отвечают дата ноды. Единица обращения к дата ноде - блок (256 килобайт для стандартных блоков динтаблиц) или фрагменты в ханках (тогда размер обращения будет кратен 4кб). В будущем мы введём квоты также и на суммарный объём обращений к дискам, но сейчас он нигде не учитывается. Тем не менее, стоит стараться отслеживать, что нагрзка на диски является адекватной, чтобы не было сюрпризов когда квоты будут вводиться.

### Режимы работы динтаблиц

Разные режимы работы динтаблиц по разному распределяют нагрузку между физическими ресурсами. Здесь мы приведём обзор наиболее распространённых сценариев

* **in memory uncompressed**. В этом режиме все чанки динтаблиц подгружаются в память таблетных нод, причём в виде разжатых блоков. При чтении необходимо только скопировать данные для ответа. Режим часто используется когда нужны гарантии низкого времени отклика (менее 10ms в том же дц) или на болших rps. Нагружаются rpc proxy, bus и lookup тредпулы таблетных нод, а также сеть между проксями и нодами.

* **in memory compressed**. Аналогично предыдущему, только блоки подгружаются в память в сжатом виде. Для чтения их приходится разжимать, разжатые блоки (на некоторое время) остаются в uncompressed block cache. При этом тратится дополнительное CPU на декомпрессию, которая, на текущий момент, может происходить как в тредпуле Compression, так и в тредпулах Query и Lookup (для селектов и лукапов соответственно).

* **in memory none**. Режим по умолчанию. Сырые чанки с данными динтаблиц читаются с дисков (на data node) и оседают в кешах блоков на таблетных нодах: compressed block cache и uncompressed block cache. Для формирования ответа блок приходится разжимать, но сжатых блоков в памяти помещается больше и разжимать их можно быстрее, чем читать с дата нод, по-этому используется двухуровневая схема с кешами. Помимо нагрузки на CPU на проксях и таблетных нодах возникает нагрузка на кеши, передачу данных между таблетной нодой и дата нодой и чтение с диска. Тут стоит также отметить, что помимо данных у чанков динтаблиц есть ещё и метаданные, которые хранятся в отдельном кеше. Перед тем как пойти за данными таблетная нода сперва читает мету и сохраняет её в versioned chunk meta cache. Если кеш мет переполняется, при чтении добавляется дополнительный раунд хождения к дата нодам - за метой.

* **lookup row cache**. В таблетной ноде включен кеш ответов на лукапы. В отличие от кеша блоков память расходуется только на данные строк, что позволяет при отсутствии локальности по ключам поместить в памяти working set большего объёма, чем в кеше блоков

* **Ханки**. Ханки позволяют выносить блобы из динтаблиц в отдельные *ханковые* чанки, данные в которых хранятся несортировано и читаются в виде отдельных значений. Изначально ханки задумывались для уменьшения объема чтения с дисков (поскольку вместо 256килобайтного блока можно прочитать отдельный ханк), но оказалось что при грамотных настройках ханки позволяют существенно уменьшить Write Amplification, разменяв его на Space Amplification. Ханковые чанки и нагрузка на них учитывается в отдельных статистиках и счэтчиках. Если вы работаете с ханками, убедитесь что у вас используются соответствующие статистики и сенсоры (обычно в их имени есть подстрока hunk) 

* **Compaction**. Компактификация в сортированных динтаблицах присутствует всегда и не является каким-то настраиваемым режимам (впрочем, сам компакшн как раз можно настраивать). Компакшн создаёт заметную нагрузку, поскольку его работа подразумевает фоновую перезапись всех данных в таблице. При настройках по умолчанию мы замечаем, что компакшн создаёт десятикратный Write Amplification: на каждый байт, записанный пользователем мы пишем 10 байт (без учёта репликации!) на диск из-за фоновой перезаписи данных. Нагрузка от компакшна заметно возрастает в моменты [форсированной компактификации](../../../user-guide/dynamic-tables/compaction#forced_compaction) или некорректно настроенной регулярной компактификации. 

## Интерфейс бандла

Завести себе бандл и аллоцировать в нём tablet node и rpc proxy вы можете самостоятельно в интерфейсе бандла. Для аллокации потребуется квота в ABC в виде cpu и ram на соответствующем кластере. Перекинуть квоту вы можете из своих квот для map-reduce.

### Аллокация таблетных нод и проксей

Для создания инстансов таблетных нод и rpc proxies нажмите на странице вашего бандла в правом верхнем углу Edit Bundle -> Resources. Введите необходимое число инстансов, выберети их тип и нажмите Confirm. Аллокация инстанса может занять заметное время, даже около часа: при аллокации на кластере создаётся новый под и система управления кластером должна подготовить для него новый контейнер, что при загруженных мапредьюсами дисках бывает долго. После того как инстанс создался, на нём автоматически появятся таблет-целлы и вы сможете им пользоваться.

В случае кросс-дц кластеров markov и pythia инстансы должны быть равномерно распределены по всем трём дц - это значит, что заказываемое число инстансов должно быть кратно трём. Дальше YT сам их аллоцирует в разных датацентрах. Колличество таблет-целлов которое при этом создаётся допускает отказ одного из трёх инстансов - это нужно для того чтобы держать внезапный отказ одного датацентра. Если рассуждать в терминах нагрузки, то полчается что инстансов должно быть в полтора раза больше, чем необходимо под нагрузку.

Если вы расширяете существующий бандл, убедитесь, что таблеты ваших таблиц перераспределились на новые ноды. Если этого не произошло, отмонтируйте и примонтируйте таблицы вручную. Это приходится делать потому что по умолчанию балансировщик таблетов равномерно распределяет только таблеты таблиц, прибитых в память, а обычные таблицы не трогает. Возможно, в будущем это изменется, но пока за перераспределением приходится следить администратору бандла.

### Конфигурирование

Помимо выбора инстанса из фиксированного набора, можно в рамках инстанса перераспределить память между категориями и CPU между тредпулами. Делается это по кнопке Edit Bundle -> Memory или Thread Pools. Для того чтобы адекватно сконфигурировать бандл, выясните в каком режиме вы пользуетесь динтаблицами, какие категории памяти и тредпулы для вас наиболее актуальны.

Ниже приведены пояснения для параметров, которые можно задать.

*Memory*

* **Tablet static** - память под таблицы, прибитые в память (атрибут таблицы `in_memory_mode` выставлен в `uncompressed` или `compressed`). Имеет смысл выкручивать, если вы всё кладёте в память.
* **Tablet dynamic** - память под буферы записи в динтаблицы (куда попадают самые свежие строки). Лучше оставить дефолтное значение: слишком большое приведёт к долгому восстановлению таблет-целла при переездах, а слишком маленькое - к повышенной нагрузке на компактификацию
* **Compressed block cache/uncompressed block cache** - кеши блоков динтаблиц, которые читаются с дисков
* **Versioned chunk meta cache** - кеш мет чанков динтаблиц, которые читаются с дисков
* **Lookup row cache** - размер кеша ответов на лукапы. Добавьте сюда памяти, если вы используете такой кеш
* **Key filter block cache** - размер кеша под фильтр отсутствющих ключей. Увеличте, если часто лукапите по несуществующим ключам и вам помогает такой фильтр

*Thread Pools*

* **Lookup thread pool size** - размер тредпула под лукапы. Повысьте за счёт селектов, если у вас нагрузка от лукапов больше чем от селектов
* **Query thread pool size** - размер тредпула под селекты. Повысьте за счёт лукапов, если нагрузка от селектов больше чем от лукапов
* **Write thread pool size** - число таблет-целлов, которое будет располагаться на инстансе. Запись в каждый таблет-целл происходит в один поток, по-этому мы назвали его write thread. Настраивать этот параметр, как и tablet dynamic память, не рекомендуется

Обратите внимание, что количество ядер в инстансе ограничено (Надпись "Total ... cores"). Также в процессе имеются другие тредпулы, в частности BusXFer, который нужен для передачи пакетов по сети. При конфигурации не стоит допускать переподписки, как минимум для загруженных трепулов.

## Дашборды

Для диагностики нагрузки и возможных проблем с производительностью на странице бандла выведены несколько дашбордов, на которых собраны графики, объединённые общей тематикой

* **Default**. Старый дашборд для бандла, на котором компактно собрано самое важное: объём, который пишется и читается, объём данных, читаемых с дисков и загруженность тредпулов Lookup, Query и Compression
* **User Load**. Дашборд, показывающий пользовательскую нагрузку на бандл: объём и количество ключей, которые пшиутся и читаются, число запросов, время отклика чтений
* **Resources**. Дашборд, показывающий утилизацию физических ресурсов таблетными нодами: CPU, память, сеть и диски. Утлизация показана как суммарно для всего бандла, так и в разрезе отдельных инстансов. При просмотре по инстансам показаны как инстансы с максимальным потреблением, так и с минимальным, что позволяет оценить дисперсию распределения нагрузки
* **CPU**. Дашборд, позволяющий понять как потребление CPU распределяется по различным тредпулам. Единицы на графиках соответствуют единицам процессорного времени одного ядра. Также приведён график утилизации по всем тредпулам, чтобы можно было быстро понять что какой-то (возможно, системный) тредпул перегружен. Отдельно стоит подчеркнуть график CPU Wait: на нём показано время, которое треды проводили в очереди, ожидая шедулинга на CPU. Если вы видете на этом графике значения, сравнимые для отдельного хоста с единицами ядер - скорее всего у вас переподписка по CPU или вам очень сильно не повезло с соседними контейнерами на том же физическом хосте
* **Memory**. Дашборд, на котором собрано потребление памяти для некоторых категорий, а также общее потребление процессами и данные по фрагментации памяти
* **Disk**. Дашборд, на котором показана нагрузка на диски: обёмы читаемых данных при лукапах и селектах, а также задержки по времени связанные с доступом до сетевых дисков; объём читаемого и записываемого при фоновых процессах, таких как компакшн; нагрузка и прогнозирование показателей для кешей блоков - этими графиками стоит пользоваться при желании изменить размеры кешей
* **LSM**. Отдельный дашборд, показывающий работу компакшна. На этом дашборде стоит остерегаться полочек на графиках running compactions - если всегда есть что покомпактить, скорее всего компакшн просто не справляется со своей работой и очередь задач на компактификацию растёт. Также стоит обращать внимание на график Write Amplification - большие значения на этом графике должны побуждать заниматься настройкой компакшна (что к сожалению непросто и скорее всего займёт у вас много времени, но в конечном счёте позволит сэкономить на железе)
* **Maintainance**. Дашборд, на котором показаны внутренние переезды таблетов и таблет-целлов, выпадения и аллокация нод. Откройте этот дашборд, если имеете дело с ошибками доступности динтаблиц - скорее всего недоступность связана с одним из событий на графиках этого дашборда
* **Network**. Дашборд, показывающий нагрузку на сеть и внутрениий RPC стек. Бывает полезен для анализа сетевых задержек между таблетными нодами и дата нодами
* **Efficiency**. Показывает то насколько хорошо настроен бандл относительно других бандлов на кластере. Если ваша линия сильно отличается от среднего по кластеру в худшую сторону - это повод задуматься о корректности настроек динтаблиц
* **Proxy Resources**. Аналогично дашборду Resources, только для Rpc Proxy
* **Proxy Detail**. Полезные метрики для диагностики работы проксей, всего понемногу

## Алерты

Поскольку нагрузка на бандл непосредственно переводится в нагрузку на CPU, память, диски и сеть, и исчерпание какого-либо из этих ресурсов хотя бы на одном инстансе приводит к заметной деградации бандла, полезно сделать алерты на то что потребление ресурса находится в разумных пределах. Также,у табленой ноды бывают косвенные признаки того, что с ней не всё в порядке: скорость применения мутаций автоматом таблет-целла, излишняя загрузка компакшна, срабатывающие троттлеры и рост очередей (который означает совсем уж нехватку ресурса). Для удобства, есть готовые шаблоны алертов сервис-провайдера в The Monitoring.

Подробнее читайте в специальном разделе документации [алерты сервис-провайдера](../../../user-guide/dynamic-tables/service-provider-alerts)

## Capacity Planning

Администратор бандла должен в первую очередь следить за тем, что бандл справляется с нагрузкой и будет справляться при росте, запуске новых проектов, снижении доступных мощностей (отключение датацентра). Есть две существенно разные задачи для capacity planning: планирование ресурсов под новую нагрузку и под прогнозируемый рост. Во втором случае задача заметно проще, поскольку можно пользоваться имеющимися графиками потребления ресурсов.

При прогнозировани роста нагрузки воспользуйтесь графиками потребления физических ресурсов. Если ваш бандл существенно полагается на использование кешей (кеши блоков, строк, фильтров), посмотрите прогнозы на графиках соответствующих кешей - хватит ли их при увеличении частоты обращений. Спланируйте увеличение количества инстансов в соответствие с ростом наиболее болезненного (доминантного) ресурса.

Для оценки размеров нового бандла под новые проекты можно использовать консервативные численные формулы из раздела [планирование ресурсов](../../../user-guide/best-practice/resource-planning#resury-dinamicheskih-tablic).

Последний, сложный случай, когда вы запускаете новый проект в уже существующем бандле. Попробуйте прикинуть, сколько вам нужно инстансов, если бы вы запускали его в отдельном бандле и посмотрите, хватает ли этих ресурсов в существующем. Учтите, что влияние кешей (блоков, строк, фильтров) крайне сложно поддаётся прогнозированию, но вам нужно будет дать ответ на вопрос: хватит ли имеющихся и что вы будете делать, если после запуска окажется что их не хватает.

Если вы пользуетесь несколькими кластерамми и реплицированными (или хаосными) таблицами, учтите, что вам нужно иметь запас на удержание всей нагрузки при -1ДЦ и на догон реплик при возвращении. Рассмотрим простой сценарий: реплицировання таблица на Маркове и реплики на двух Сенеках. На Маркове учёт -1ДЦ входит в ресурсную модель: при аллокации бандла вы сразу заказываете дополнительные инстансы. На Сенеке вам нужно иметь двухкратный запас ресурсов для читающих запросов: это позволит пережить даунтайм. Если у вас будет также двухкратный запас ресурсов на запись, то после даунтайма репликация сможет работать на двойной скорости, тогда кластер догонится до актуального состояния за то же самое время, которое занимал даунтайм

Не забывайте, что при использовании реплицированных и хаосных динтаблиц, вам нужно следить за бандлами на всех кластерах: и где располагается реплицированная динтаблица, и где располагаются реплики.

Большая сложность с планирование нагрузки может возникать, если она у вас получилась очень неравномерная. Для начала стоит попробовать выровнить нагрузку, для чего использовать либо шардирование по другому ключу (в т.ч. по хешу), либо аккуратно настроть автоматическое шардирование. Подробнее о шардировании читайте в [документации про шардирование](../../../user-guide/dynamic-tables/resharding). Если выровнить нагрузку не получится, то все рассчёты нужно делать, учитывая диcбаланс, иначе вы можете оказаться в ситуации, что самому нагруженному инстансу не хватит ресурсов и это будет выглядеть как неработоспособность всех ваших динтаблиц

Помимо инстансов, вам нужно также заказывать квоту в аккаунт под чанки динтаблиц. Учитывайте, что сортированные динтаблицы хранят данные с избыточностью (см. модель данных в документации на [сортированные динтаблицы](../../../user-guide/dynamic-tables/sorted-dynamic-tables)). Фактическое занимаемое место будет больше чем размер данных, которые вы прочитаете. Коэффициент увеличения зависит от настроек компакшна, но лучше заплатить местом, чем пытаться выкрутить компакшн до предела - так вы только сделаете бандл хрупким и помешаете своим читающим запросам. Рассчитывайте объём с запасом. Количество чанков считайте исходя из размеров динтабличных чанков в **64 мегабайта** - это значение по умолчанию и использование больших размеров опять же приведёт к росту нагрузки на компакшн. Как администратор бандла, не забудьте проверить, что вы работаете с медиумом в котором SSD диски (ssd_blobs или nvme_blobs). Единственный кластер, на котором в медиуме default SSD диски - Марков.

В бандле есть также квота на количество таблетов. Она служит предохранительным целям. Адекватное значение можно выставить из рассчёта 100 таблетов на таблет-целл (т.е. 1000 таблетов на инстанс, если у вас в настройках бандла размер write thread pool равен 10). Значения больше 1000 на таблет-целл возможны, но не рекомендуются.

Также ознакомьтесь с инструкцией по capacity planning бандла в разделе [планирование ресурсов](../../../user-guide/best-practice/resource-planning#resury-dinamicheskih-tablic).

## Прочее

Тут собраны разные другие советы, которые бывают полезны пользователям динтаблиц

* Реплицированные динтаблицы не шардируются автоматически. Более того, решардировать уже созданную динтаблицу невозможно - для увеличения таблетов существующую придётся пересоздать.
* Упорядоченные динтаблицы также не шардируются автоматически.
* Если вы создаёте динтаблицы в map-reduce, учитывайте что так получаются неоптимальные чанки. Часть проблем можно полечить, если следовать [документации](../../../user-guide/dynamic-tables/mapreduce), для оставшихся придётся добавить запуск [форсированной компактификации](../../../user-guide/dynamic-tables/compaction#forced_compaction). Помните, что максимальный размер строки в динтаблицах не должен превышать 128 мегабайт по всем версиям, и это ограничение более строгое, чем для статических.
* Не забывайте следить за равномерностью нагрузки. Если нагрузка существенно не равномерно, по времени, ключам или таблицам - вам нужно это учитывать при планировании нагрузки на бандл.
* Обязательно сделайте тестовый контур на тестовых кластерах - так вы будете уверены, что когда мы обновим продакшн кластера, ваш бандл будет работать как ожидается.
* Помните про документацию по [диагностике](../../../user-guide/dynamic-tables/dynamic-tables-diagnostics) проблем в динтаблицах и [памятку по профилированию](../../../user-guide/dynamic-tables/dynamic-tables-profiling).
* Если вы хотите глубже разбираться в устройстве динтаблиц, смотрите свежие записи наших [семинаров и выступлений](../../../other/video-posts) а также старые обзорные [записи](../../../user-guide/dynamic-tables/dynamic-tables-internals).
